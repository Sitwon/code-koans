---
layout: default
title: Code Koans
---
# Code Koans
### A collection of maxims from the world of computer programming

#### Programming rules of thumb
1. [Zero One Infinity rule](http://en.wikipedia.org/wiki/Zero_one_infinity_rule): Arbitrary limits on the number of instances of a particular entity should not be allowed. An entity should either be forbidden entirely, one should be allowed, or any number of them should be allowed.
1. [DRY](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself): Don't Repeat Yourself.
1. [Rule of three](http://en.wikipedia.org/wiki/Rule_of_three_%28computer_programming%29): Code can be copied once, but when the same code is used three times it should be extracted into a new procedure.
1. [Gall's law](http://en.wikipedia.org/wiki/Gall%27s_law): A complex system that works is invariably found to have evolved from a simple system that worked. The inverse proposition also appears to be true: A complex system designed from scratch never works and cannot be made to work. You have to start over, beginning with a working simple system.
1. [Brooks's law](http://en.wikipedia.org/wiki/Brook%27s_law): "Adding manpower to a late softare project makes it later." "Nine women can't make a baby in one month."
1. "Hence plan to throw one \[implementation\] away; you will, anyhow." --[Fred Brooks](http://en.wikipedia.org/wiki/The_Mythical_Man-Month)
1. [90-90 rule](http://en.wikipedia.org/wiki/Ninety-ninety_rule): "The first 90 percent of the code accounts for the first 90 percent of the development time. The remaining 10 percent of the code accounts for the other 90 percent of the development time." --Tom Cargill, Bell Labs
1. [Pareto principle](http://en.wikipedia.org/wiki/Pareto_principle), a.k.a. 80-20 Rule: 80% of the effects come from 20% of the causes.
1. "There are three hard problems in Comptuer Science, naming things and off-by-one errors." --Old programming joke (as told by [Yermo Lamers](http://a-software-guy.com/))
1. [Rubber ducking](http://en.wikipedia.org/wiki/Rubber_duck_debugging), a.k.a. Talk to the Bear: When debugging code, explain it line-by-line to another person, even if it's just a rubber duck or teddy bear.
1. [Postel's law](http://en.wikipedia.org/wiki/Robustness_principle): Be conservative in what you do, be liberal in what you accept from others.
1. [Sturgeon's Revelation](http://en.wikipedia.org/wiki/Sturgeon%27s_Law): Ninety percent of everything is crap.
1. [Hofstadter's Law](http://en.wikipedia.org/wiki/Hofstadter%27s_law): It always takes longer than you expect, even when you take into account Hofstadter's Law.
1. [Wirth's law](http://en.wikipedia.org/wiki/Wirth%27s_law): Software is getting slower more rapidly than hardware becomes faster.
1. [Lehman's laws of software evolution](http://en.wikipedia.org/wiki/Lehman%27s_laws_of_software_evolution):
  * S-programs are written according to an exact _specification_ of what the program can do
  * P-programs are written to implement certain _procedures_ that completely determine what the program can do
  * E-programs are written to perform some real-world activity; how they should behave is strongly linked to the _environment_ in which they run, and these programs need to adapt to varying requirements and circumstances in that environment.
  1. Continuing Change -- E-type systems must be continually adapted or they become progressively less satisfactory.
  1. Increasing Complexity -- As an E-type system evolves its complexity increases unless work is done to maintain or reduce it.
  1. Self Regulation -- E-type system evolution process is self-regulating with distribution of product and process measures close to normal.
  1. Conservation of Organisational Stability -- The average effective global activity rate in an evolving E-type system is invariant over product lifetime.
  1. Conservation of Familiarity -- As an E-type system evolves all associated with it, developers, sales personnel, users, for example, must maintain mastery of its content and behavior to achive satisfactory evolution. Excessive growth diminishes that mastery. Hence the average incremental growth remains invariant as the system evolves.
  1. Continuing Growth -- The functional content of E-type systems must be continually increased to maintain user satisfaction over their lifetime.
  1. Declining Quality -- The quality of E-type systems will appear to be declining unless they are rigorously maintained and adapted to operational environment changes.
  1. Feedback System -- E-type evolution processes constitute multi-level, multi-loop, multi-agent feedback systems and must be treated as such to achieve significant improvement over any reasonable base.
1. [Greenspun's tenth rule](http://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule): Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden slow implementation of half of Common Lisp.
1. [Zawinski's law of software envelopment](http://en.wikipedia.org/wiki/Jamie_Zawinski#Zawinski.27s_law_of_software_envelopment): Every program attempts to expand until it can read mail. Those programs which cannot so expand are replaced by ones which can.
1. [Amdahl's law](http://en.wikipedia.org/wiki/Amdahl's_law): The speedup of a program using multiple processors in parallel computing is limited by the time needed for the sequential fraction of the program.
1. "Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live." --John Woods

##### [Abstraction principle](http://en.wikipedia.org/wiki/Abstraction_principle_%28computer_programming%29)
Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.

#### [Common code smells](http://en.wikipedia.org/wiki/Code_smell)
1. Duplicated code
1. Long method
1. Large class
1. Too many parameters
1. Feature envy: a class that uses methods of another class excessively
1. Inappropriate intimacy
1. Refused bequest
1. Lazy class / Freeloader
1. Contrived complexity
1. Excessively long identifiers
1. Excessively short identifiers
1. Excessive use of literals / Magic numbers
1. Ubercallback
1. Complex conditionals

#### C++ Programming
1. [Rule of three](http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29): If a class defines one of the following it should probably explicitly define all three.
  * destructor
  * copy constructor
  * copy assignment operator

#### [PEP 20: The Zen of Python](http://www.python.org/dev/peps/pep-0020/)
1. Beautiful is better than ugly.
1. Explicit is better than implicit.
1. Simple is better than complex.
1. Complex is better than complicated.
1. Flat is better than nested.
1. Sparse is better than dense.
1. Readability counts.
1. Special cases aren't special enough to break the rules.
1. Although practicality beats purity.
1. Errors should never pass silently.
1. Unless explicitly silenced.
1. In the face of ambiguity, refuse the temptation to guess.
1. There should be one-- and preferably only one --obvious way to do it.
1. Although that way may not be obvious at first unless you're Dutch.
1. Now is better than never.
1. Although never is often better than *right* now.
1. If the implementation is hard to explain, it's a bad idea.
1. If the implementation is easy to explain, it may be a good idea.
1. Namespaces are one honking great idea -- let's do more of those!

#### [Unix philosophy](http://en.wikipedia.org/wiki/Unix_philosophy)
##### [Doug McIlroy](http://en.wikipedia.org/wiki/Douglas_McIlroy)
1. Write programs that do one thing and do it well.
1. Write programs to work together.
1. Write programs to handle text streams, because that is a universal interface.

##### [Eric S. Raymond (ESR)](http://en.wikipedia.org/wiki/Eric_S._Raymond)
1. Rule of Modularity: Developers should build a program out of simple parts connected by well defined interfaces, so problems are local, and parts of the program can be replaced in future versions to support new features. This rule aims to save time on debugging complex code that is complex, long, and unreadable.
1. Rule of Clarity: Developers should write programs as if the most important communication is to the developers, including him- or herself, whom will read and maintain the program rather than the computer. This rule aims to make code readable and comprehensible for whomever works on the code in future.
1. Rule of Composition: Developers should write programs that can communicate easily with other programs. This rule aims to allow developers to break down projects into small, simple programs rather than overly complex monolithic programs.
1. Rule of Separation: Developers should separate the mechanisms of the programs from the policies of the programs; one method is to divide a program into a front-end interface and back-end engine that interface communicates with. This rule aims to let policies be changed without destabilizing mechanisms and consequently reducing the number of bugs.
1. Rule of Simplicity: Developers should design for simplicity by looking for ways to break up program systems into small, straightforward cooperating pieces. This rule aims to discourage developers’ affection for writing “intricate and beautiful complexities” that are in reality bug prone programs.
1. Rule of Parsimony: Developers should avoid writing big programs. This rule aims to prevent overinvestment of development time in failed or suboptimal approaches caused by the owners of the program’s reluctance to throw away visibly large pieces of work. Smaller programs are not only easier to optimize and maintain; they are easier to delete when deprecated.
1. Rule of Transparency: Developers should design for visibility and discoverability by writing in a way that their thought process can lucidly be seen by future developers working on the project and using input and output formats that make it easy to identify valid input and correct output. This rule aims to reduce debugging time and extend the lifespan of programs.
1. Rule of Robustness: Developers should design robust programs by designing for transparency and discoverability, because code that is easy to understand is easier to stress test for unexpected conditions that may not be foreseeable in complex programs. This rule aims to help developers build robust, reliable products.
1. Rule of Representation: Developers should choose to make data more complicated rather than the procedural logic of the program when faced with the choice, because it is easier for humans to understand complex data compared with complex logic. This rule aims to make programs more readable for any developer working on the project, which allows the program to be maintained.[6]
1. Rule of Least Surprise: Developers should design programs that build on top of the potentials users' expected knowledge; for example, ‘+’ should always mean addition in a calculator program. This rule aims to encourage developers to build intuitive products that are easy to use.
1. Rule of Silence: Developers should design programs so that they do not print unnecessary output. This rule aims to allows other programs and developers to pick out the information they need from a program's output without having to parse verbosity.
1. Rule of Repair: Developers should design programs that fail in a manner that is easy to localize and diagnose or in other words “fail noisily”. This rule aims to prevent incorrect output from a program from becoming an input and corrupting the output of other code undetected.
1. Rule of Economy: Developers should value developer time over machine time, because machine cycles as of the year 2013 are relatively inexpensive compared to prices in the 1970s. This rule aims to reduce development costs of projects.
1. Rule of Generation: Developers should avoid writing code by hand and instead write abstract high-level programs that generate code. This rule aims to reduce humans errors and save time.
1. Rule of Optimization: Developers should prototype software before polishing it. This rule aims to prevent developers from spending too much time for marginal gains.
1. Rule of Diversity: Developers should design their programs to be flexible and open. This rule aims to make programs flexible, allowing them to be used in other ways than their developers intended.
1. Rule of Extensibility: Developers should design for the future by making their protocols extensible, allowing for easy plugins without modification to the program's architecture by other developers, noting the version of the program, and more. This rule aims to extend the lifespan and enhance the utility of the code the developer writes.

##### Mike Gancarz
1. Small is beautiful.
1. Make each program do one thing well.
1. Build a prototype as soon as possible.
1. Choose portability over efficiency.
1. Store data in flat text files.
1. Use software leverage to your advantage.
1. Use shell scripts to increase leverage and portability.
1. Avoid captive user interfaces.
1. Make every program a filter.

##### [Worse is better](http://en.wikipedia.org/wiki/Worse_is_better)
1. Simplicity of both interface and implementation are more important than any other attributes of the system-- including correctness, consistency, and completeness.
1. Simplicity over perfection.

#### See Also
* [More wisdom from ESR.](http://quotes.cat-v.org/programming/)

